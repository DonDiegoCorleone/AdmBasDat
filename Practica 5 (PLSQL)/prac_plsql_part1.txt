--1
create or replace FUNCTION CURSO_ACTUAL RETURN VARCHAR2 AS
CADENA VARCHAR2(20);
BEGIN
CADENA := substr(extract(year from sysdate),3,4);
IF(to_date('05-10-'||CADENA,'DD-MM-YY') < sysdate) 
THEN CADENA:=CADENA||TO_CHAR(TO_NUMBER(CADENA)+1);
ELSIF TRUE THEN CADENA := TO_CHAR(TO_NUMBER(CADENA)-1)||CADENA;
END IF;
RETURN CADENA;
END CURSO_ACTUAL;
--2
create or replace FUNCTION OBTEN_GRUPO_ID(Titulacion VARCHAR2,Curso NUMBER, Letra VARCHAR2) RETURN VARCHAR2 AS
cod_titu NUMBER;
cod_gr NUMBER;
BEGIN
SELECT CODIGO INTO cod_titu from TITU where NOMBRE LIKE Titulacion;
SELECT ID INTO cod_gr from GRUPO where CURSO LIKE Curso and LETRA LIKE Letra and TITU_CODIGO LIKE cod_titu;
RETURN to_char(cod_gr);
END OBTEN_GRUPO_ID;
--3
CREATE GLOBAL TEMPORARY TABLE "SECRETARIA"."TEMP_ASIGNATURAS"
("CODIGO" NUMBER, GRUPO VARCHAR2(10)
) ON COMMIT DELETE ROWS;
--4 version medio buena
create or replace procedure normaliza_asignaturas (pcadena varchar2, Titulacion varchar2 default null) 
AS
codigo number;
letra varchar2(30);
id_codigo varchar2(30);
id_grupo varchar2(30); 
NUM number;
COUNTER number; 
BEGIN
COUNTER := 1;
select * into NUM from(select count(*) from (select regexp_substr('pcadena','[^,]+', 1, level) from dual connect by regexp_substr('pcadena', '[^,]+', 1, level) is not null));--numero de grupos que hay en la cadena.

    while ( COUNTER <= NUM ) loop
         select * into codigo from(select regexp_substr(pcadena,'[^,]+', 1, level) from dual where rownum= COUNTER  connect by regexp_substr(pcadena, '[^,]+', 1, level) is not null);
         codigo := substr(codigo,1,3);
         select * into letra from (select regexp_substr(pcadena,'[^,]+', 1, level) from dual where rownum= COUNTER  connect by regexp_substr(pcadena, '[^,]+', 1, level) is not null);
         letra := substr(letra,5, 1);
         id_grupo := OBTENER_GRUPO_ID(Titulacion, substr(codigo,1,1), letra);

         insert into "SECRETARIA"."TEMP_ASIGNATURAS" values (codigo, id_grupo);

         COUNTER := COUNTER + 1; 
         END LOOP;

END normaliza_asignaturas;
/
